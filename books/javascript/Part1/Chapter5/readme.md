# 《你不知道的javascript上》学习杂记
## 第五章
### 作用域闭包
5.1 闭包无处不在，需要的是识别并加以利用。
5.2 实质问题
  当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用 域之外执行。
  eg：
    function foo() {
      var a = 2;
      function bar() {
        console.log( a ); // 2 
      }
      bar(); 
    }
    foo()；
  解析：
    基于词法作用域的查找规则(RHS引用查询)。
    *词法作用域查找规则只是闭包的一部分。
  eg：
    function foo() {
      var a = 2;
      function bar() { 
        console.log( a ); 
      }
      return bar; 
      }
      var baz = foo(); 
      baz(); // 2 —— 朋友，这就是闭包的效果
  解析：
    在 foo() 执行后，其返回值（也就是内部的 bar() 函数）赋值给变量 baz 并调用 baz()，实际上只是通过不同的标识符引用调用了内部的函数 bar()。

      *闭包的本质源自两点，词法作用域和函数当作值传递。 词法作用域，就是，按照代码书写时的样子，内部函数可以访问函数外面的变量。 引擎通过数据结构和算法表示一个函数，使得在代码解释执行时按照词法作用域的规则，可以访问外围的变量，这些变量就登记在相应的数据结构中。

      创建新的函数就会产生闭包。
      eg:
      function init() {
        var name = "Mozilla"; // name 是一个被 init 创建的局部变量
        function displayName() { // displayName() 是内部函数，一个闭包
        alert(name); // 使用了父函数中声明的变量
        }
        displayName();
      }
      init();

      *词法作用域中，内部函数可以访问外部函数的作用域，这就是闭包带来的效果。
  - 闭包模拟私有方法
      eg：1.js, 2.js
      以这种方式使用闭包，提供了许多与面向对象编程相关的好处 —— 特别是数据隐藏和封装。