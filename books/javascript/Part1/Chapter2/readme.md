# 《你不知道的javascript上》学习杂记
## 第二章
### 词法作用域
2. 作用域： 两种工作模型：词法作用域(普遍)、动态作用域(Bash、Perl等)
 2.1 词法阶段
  大部分编译器第一个工作阶段：词法化(单词化)
  词法作用域就是定义在词法阶段的作用域。(还有欺骗词法作用域的方法)
  eg:
     function foo(a) {
      var b = a * 2;
      function bar(c) { 
        console.log( a, b, c ); 
      }
      bar( b * 3 ); 
     }
     foo( 2 ); // 2, 4, 12
     解析：
       1. 包含在整个全局作用域：foo
       2. 包含在 foo 所创建的作用域：a、bar 和 b
       3. 包含在 bar 所创建的作用域：c
  作用域的查找：
    1. 作用域查找会在找到第一个匹配的标识符时停止。
    2. 在多层的嵌套作用域中可以定义同名的 标识符，这叫作“遮蔽效应”。
    3. 全局变量会自动成为全局对象（比如浏览器中的 window 对象）的属性。eg:window.a  通过这种技术可以访问那些被同名变量所遮蔽的全局变量。但非全局的变量 如果被遮蔽了，无论如何都无法被访问到。
 2.2 欺骗词法：
      程序运行时修改词法作用域：
          JavaScript 中有两种机制来实现这个目的。但欺骗词法作用域会导致性能下降。
  2.2.1 
      eval() 方法:可以在你写的代码中用程序生成代码并 运行，就好像代码是写在那个位置的一样。
        eg:
           function foo(str, a) { 
             eval( str ); // 欺骗！ console.log( a, b );
              }
           var b = 2; 
           foo( "var b = 3;", 1 ); // 1, 3
        解析: eval(..) 调用中的 "var b = 3;" 这段代码会被当作本来就在那里一样来处理。由于那段代 码声明了一个新的变量 b，因此它对已经存在的 foo(..) 的词法作用域进行了修改。
  2.2.2 with()方法：with 通常被当作重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身。
   eg(1):
      var obj = {
        a: 1,
        b: 2,
        c: 3 
      };
      // 单调乏味的重复 "obj"
      obj.a = 2;
      obj.b = 3;
      obj.c = 4;
      // 简单的快捷方式
      with (obj) { 
        a = 3;
        b = 4; 
        c = 5; 
      } 
   eg(2):
    function foo(obj) {
      with (obj) { 
        a = 2; 
      } 
    }
    var o1 = { a: 3 };
    var o2 = { b: 3 };

    foo( o1 ); 
    console.log( o1.a ); // 输出：2 

    foo( o2 ); 
    console.log( o2.a ); // 输出:undefined 
    console.log( a );    // 输出:2 -> a 被泄漏到全局作用域上
  解析:
    with 可以将一个没有或有多个属性的对象处理为一个完全隔离的词法作用域，因此这个对 象的属性也会被处理为定义在这个作用域中的词法标识符。
    o2 的作用域、foo(..) 的作用域和全局作用域中都没有找到标识符 a，因此当 a＝2 执行 时，自动创建了一个全局变量（因为是非严格模式）。
  2.2.3 性能问题
    eval(..) 和 with 会在运行时修改或创建新的作用域，以此来欺骗其他在书写时定义的词 法作用域，但 JavaScript 引擎会在编译阶段进行数项的性能优化。如果引擎在代码中发现了 eval(..) 或 with，那么程序运行起来一定会变得非常慢。