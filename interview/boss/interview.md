# 涂鸦科技一面(35min)

# 自我介绍
# 长列表优化（细）
# 怎么判断是否在可视化视窗。
# react服务端渲染（细）
# SEO优化
# 加载性能优化
# 图片懒加载
# webpack有自己写一个loader 或者 plugin吗？
# 你是怎么判断一个项目用react还是vue好一点点？
# react 15 你了解吗
# react15 到 16 的时候有一个 React Fiber 你知道吗？
# vue和react diff算法的区别
# 怎么在github上仓库进行多人合作代码开发
# http1.0 1.1 2.0 的区别
# 怎么实现域名分区，有自己实践过吗？


# 海致星图一面（40min)

# 自我介绍
# 上来看到我vue写了看了源码，就问我看了什么，我说看了路由的，就问我路由守卫一时懵逼了。
# react的生命周期
# 获取react组件里面的某个方法最早在哪个生命周期（componentWillMount()）
# 获取真实dom最早在那个生命周期（componentDidMount()）
# react/vue 加载性能优化
# 玩具浏览器怎么实现的？
# 浏览器有哪几个进程
# 老浏览器只有一个进程，现代浏览器有多个进程，他们之间对比有什么优劣
多个进程之间是独立的，配合需要消耗一些额外的资源；一个进程容易阻塞等等，，
# tcp四次挥手巨详细的
1）客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。
2）服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。
3）客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。
4）服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。
5）客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。
6）服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。
# 客户端收到服务器的连接释放报文后是立马断开吗？
注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。

# 过多长时间？
2∗∗MSL（最长报文段寿命）
# 为什么是这个时间，1*msl不可以吗？
原因客户端给服务器端发送确认包之后，等待两个的原因是确保客户端发送的确认包，服务器收到了，保证这个链路上没有数据包了。保证最精确的完成。
# http1.0 1.1 2.0
# Last-Modified / If-Modified-Since 和 Etag / If-None-Match 区别
1. 在精确度上，Etag 优于 Last-Modified
Etag 是按照资源内容做标记，因此可以准确的感知到资源的变化
Last-Modified 在一些特殊情况不能准确的感知资源的变化(这也是 Etag 产生的原因)：
- 一下文件可能会进行周期性的更改，编辑了资源文件，但是文件内容没有更改，这样也会造成缓存失效，但这个时候并不希望客户端认为这个文件被修改了而重新 GET  
- Last-Modified 能够感知的时间单位是秒，如果文件在 1 秒内修改了 N 次，这个时候 Last-Modified 无法判断修改  
2. 在性能上，Last-Modified 优于 Etag
Last-Modified 只是记录一个时间点，而 Etag 需要根据文件的具体内容生成 hash 值

# Etag是怎么生成的？（乱说了，人傻了）
根据文件内容通过MD5加密生成一个hash值
# http 3.0知道吗？
不知
# webpack怎么打包文件的（流程）参考蔡刚大佬的博客
Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：

1. 初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数
2. 开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有的配置的插件，执行对象的 run 方法开始执行编译
3. 确定入口：根据配置中的 entry 找出所有的入口文件
4. 编译模块：从入口文件出发，调用所有配置的 loader 对模块进行编译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了处理
5. 完成模块编译：在经过 loader 对于模块的编译后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系
6. 输出资源：根据入口和模块之间的依赖关系，组成一个个包含多个模块的 chunk，再把每个 chunk 转换成一个单独的文件加入到输出列表，这一步是可以修改输出内容的最后机会
7. 输出完成：在确定好输出内容之后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统
# webpack 性能优化 参考蔡刚大佬的博客
1. 提高打包速度
- happyPack：因为 node 是单线程的，Webpack 是基于 node 的，无法使用现代机器的多核处理器的优势，打包时间要很久，happyPack 的作用就是开启多线程打包，提高打包速度，在模块很大的时候才有效
在 plugin 了 new 这个插件，可以指定线程池的数量(根据 cpu 核数)
- 分离基础库：第三方库比如 react、react-dom，这些库长时间不会改变，分离出来让它不打包或者减少打包的次数(比如单独入口)
将不怎么需要更新的第三方库脱离 Webpack 打包，不被打入 bundle 中，从而减少打包时间，比如 jQuery 用 script 标签引入
- DLL 动态链接库：让一些基本不会改动的代码先打包成静态资源，避免反复编译浪费时间(利用缓存)
- 动态导入的，把动态导入的代码单独打包，显然比打包在一块优势
2. 优化前端性能
- http://www.ihorace.cn/interview/Webpack/Webpack%E4%BC%98%E5%8C%96%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD.html

# 会实现插件吗
# 在某个文件里面引入了一个包，怎么进行单独打包到每一个chunk里面去？
配置externals
# ES6语法有用过哪些
# 箭头函数和普通函数的区别
# 里面可以使用new吗
# 为什么不可以
箭头函数没有prototype属性，没法比指定
# forEach 和 map 的区别
# 不定宽高的水平垂直居中


# 快手 面试（20min 噩梦kill）
# 来了一个深拷贝输出的读代码的题目
# 实现深浅拷贝
# 基本数据类型
# 原型链
# 实现左边固定40px,右边自适应
# 事件循环的经典读代码的题目，我把promise的reslove 和 then 的顺序搞错了
# 手写数组里面多个对象的属性的排序

整体不难就是没答好什么被kill秒杀了


# 百度面试（40min)

# 介绍一个项目
# 小程序和h5的区别
# vue 和 h5的区别
# 虚拟dom
# 虚拟dom为什么比 原生dom写页面更好
# mvvm
# defineproperty的缺陷，为什么有这些缺陷
# defineproperty 怎么实现的对数组的监听
# vue 组件间通信
# vue优点
# position 所有
# 实现两个div 上面自适应，下面固定40px
# 把一个数组里面的所有的零删除

整体下来都是原理方面从另一个角度提问，自己理解不太深，也不熟，没答好，代码题的话，怎么说一言难尽。